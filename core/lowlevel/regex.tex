\ExplSyntaxOn{}
% Matches { # | #d# | #d# + # | #d# - # } while ignoring spaces
\regex_const:Nn \c__valid_dice_regex { \A\s*(\d*)[dD](\d+)(.*)\s*\Z }

\seq_new:N \l__dice_args_seq
\tl_new:N \l__dice_number_tl
\tl_new:N \l__dice_sides_tl
\tl_new:N \l__dice_mod_tl

\msg_new:nnn { rpg } { dice / invalid_argument } { Invalid~argument~``#1''~passed~to~\noexpand\RpgDice. }

% Another Useful regex strings
\regex_const:Nn \c__pos_int_regex { \d+ }

\cs_new_protected:Npn \__rpg_dice_parse:n #1
{
	 \group_begin:
      \regex_extract_once:NnNTF { \c__valid_dice_regex } { #1 } \l__dice_args_seq
        {
          \seq_pop_left:NN \l__dice_args_seq \l_tmpa_str % Don't need the full match
          \seq_pop_left:NN \l__dice_args_seq \l__dice_number_tl % # of dice
          \seq_pop_left:NN \l__dice_args_seq \l__dice_sides_tl % # of sides
        %   \seq_pop_left:NN \l__dice_args_seq \l__dice_mod_sign_tl % +/- for add/sub
          \seq_pop_left:NN \l__dice_args_seq \l__dice_mod_tl % modifier
		

		\fp_set:Nn \l_tmpa_fp { \tl_if_empty:NTF \l__dice_mod_tl { 0 } { \l__dice_mod_tl } }
		

          % --- Pass everything to the formatter ---
          \__rpg_dice_formatter:nnn
		  				{ \l__dice_number_tl }     % #1: Number/Dice Count (can be empty = 1)
            			{ \l__dice_sides_tl }      % #2: Size of dice
            			{ \fp_compare:nNnT { \fp_use:N \l_tmpa_fp } { > } { 0 }{+}\fp_use:N \l_tmpa_fp} % #3 final computed modifier (with + if positive)
        }
        {
			 \msg_error:nnn { rpg } { dice / invalid_argument } { #1  }
			 }
    \group_end:
}


