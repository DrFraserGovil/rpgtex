\ExplSyntaxOn

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Stat environments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Stat block made to look like stat blocks in the PHB.
% Some some modifications made to include 2024 updates

%%%%%% Main box
	\DeclareTColorBox {RpgStatBox} { O{} m }
	{
	enhanced,
	before~skip      = 12pt plus 3pt minus 3pt,
	boxrule          = 2pt,
	% breakable,
	parbox           = false,
	boxsep           = 2pt,
	toptitle         = 8pt,
	top              = 0pt,
	left             = 2pt,
	right            = 2pt,
	bottom           = 7pt,
	rounded~corners,
	arc=4mm,
	oversize         = 0pt,
	colback          = statblockbg,
	colbacktitle     = statblockbg,
	colframe         = statblockoutline,
	fontupper        = \RpgFontStatBlockBody,
	fontlower        = \RpgFontStatBlockBody,
	title            = {#2},
	#1
	}



%%%%%% RpgStat Environment

	

	% %%Standard dnd stat environment

	\RpgStatTextFormat{
		\rpg_stat_box:nn{}{#1}
				#2
		\end{RpgStatBox}
	}

	\RpgStatCardFormat{
		
		\subsection{#1}
			#2
	}
	

	%%Starred version is a floating, two column version used for boss stats
	%%Takes two sets of optional arguments: one to the float, one to the tcolorbox
	\NewDocumentEnvironment {RpgStat*} { O{} O{} m +b}
	{
		\begin{figure*}[#1]
		\centering
		\rpg_stat_box:nn {#2} {#3}

		\vspace{-1em}
		\begin{multicols}{2}
		#4
	}
	{
		\end{multicols}
		\end{RpgStatBox}
		\end{figure*}
	}


	%%Begins the environment with different arguments depending on print mode
	\NewDocumentCommand \rpg_stat_box:nn { m m }
	{
		\RpgSetStatName{#2} %make #the stat's name accessible via macro so stat blocks can easily change names
		\bool_if:NTF \l__rpg_show_background_bool
		{
			\begin{RpgStatBox}[#1]{}
		}
		{
			\begin{RpgStatBox}[#1,colback=white,colframe=black!30!white]{}
		}
		\vspace{5pt}{\RpgFontStatBlockTitle \color{titlered}#2}

		\tl_if_empty:eF{\l__crtype_tl}
		{
			\begin {hangingpar}
				\textit {\l__crtype_tl}
			\end {hangingpar}
		}
		\RpgStatBasics
	}


%%%%%% Internal Helper functions
	% A description variant used to list creature attributes.
	\newlist {__rpg_stat_attributes} {description} {1}
	\setlist [__rpg_stat_attributes]
	{
		before   = \color {titlered},
		font     = \RpgFontStatBlockBody,
		labelsep = \l__rpg_space_dim,
		nosep,
	}

	% Only prints the item label if the value was supplied
	\cs_new_protected_nopar:Npn \__rpg_if_stat_attribute:nn #1#2
	{
		\tl_if_empty:NF {#1}
		{ \item [#2] #1 }
	}

	% Function to format signed integers
	\cs_new_protected_nopar:Npn \__rpg_format_signed_integer:N #1
	{
		\int_compare:nNnTF {#1} < {0}
		{ - }
		{+}
		\int_abs:n {#1}
	}

	\msg_new:nnn{rpg}{bad-ability}{Cannot~parse~#1~as~a~valid~ability~score}
	\cs_new_protected_nopar:Npn \__rpg_ability_score_modifier:N #1
	{
		\regex_match:NnTF \c__pos_int_regex {#1}
		{
			\fp_eval:n { floor ( ( #1 - 10 ) / 2 ) }
		}
		{
			
			\msg_error:nnn{rpg}{bad-ability}{#1}
		}
	}
	\cs_new_protected_nopar:Npn \__rpg_store_ability_score_modifier:NV #1#2
	{
		\regex_match:NVTF \c__pos_int_regex {#2}
		{
			% \int_gset:Nn{#2}{\fp_eval:n { floor ( ( #1 - 10 ) / 2 ) }}
			\int_gset:Nn #1 { \fp_eval:n { floor ( ( #2 - 10 ) / 2 ) } }
		}
		{
			
			\msg_error:nnn{rpg}{bad-ability}{#2}
		}
	}
			

	\cs_new_protected_nopar:Npn \__rpg_save_modifier:Nn #1 #2
	{
			% Add proficiency bonus if the boolean #2 is true
			\bool_if:NT #2
			{\int_set:Nn \l_tmpa_int { \fp_eval:n { floor ( ( #1 - 10 ) / 2 ) } }
			\int_add:Nn \l_tmpa_int { \g__rpg_proficiency_bonus_int }

			% Format and return the result
		\exp_args:Nf \__rpg_format_signed_integer:N \l_tmpa_int}
	}

	\int_new:N \l__ability_modifier_int
	\int_set:Nn \l__ability_modifier_int {0}
	\cs_new:Npn \__rpg_get_ability_mod:Nn #1#2
	{
		%%retrieve ability scores based on string names
		% \group_begin:
		\tl_set:Nn \l_tmpa_tl { \tl_use:N #1 }
		\tl_set:Nn \l_tmpb_tl { l__\l_tmpa_tl _tl }
		\cs_if_exist:cTF { \l_tmpb_tl }
		{
			\int_set:Nn \l__ability_modifier_int { \fp_eval:n {#2 + floor ( ( \tl_use:c{ \l_tmpb_tl } - 10 ) / 2 ) } }
			% \int_set:Nn \l_tmpa_int { \fp_eval:n { floor ( ( \tl_use:c{ \l_tmpb_tl } - 10 ) / 2 ) } }
			% \exp_args:Nf \l_tmpa_int
		}
		{
			\msg_set:nnnn { rpg } { bad-modifier } { #1~expands~to~\l_tmpa_tl} { looong }
			\msg_error:nnnn { rpg } { bad-modifier }
			+0
		}

    % \group_end:
}
%%%%%% Variable definitions
	\tl_new:N \l__initiative_bonus_tl
	\bool_new:N \l__manual_initiative_bool

	%% This is a big long keyval section, there's no real way to make it pretty

				
	\RpgStatAddProperty{type}{ \l__crtype_tl}{}
	\RpgStatAddProperty{armor-class}{ \l__armor_class_tl}{10}
	\RpgStatAddProperty{hit-points}{\l__hit_points_tl}{\RpgDice{1d8}}
	\RpgStatAddProperty{speed}{\l__speed_tl}{30ft}
	\RpgStatAddProperty{initiative}{\l__initiative_bonus_tl}{\q_no_value}
	\RpgStatAddProperty{str}{\l__str_tl}{10}
	\RpgStatAddProperty{dex}{\l__dex_tl}{10}
	\RpgStatAddProperty{con}{\l__con_tl}{10}
	\RpgStatAddProperty{int}{\l__int_tl}{10}
	\RpgStatAddProperty{wis}{\l__wis_tl}{10}
	\RpgStatAddProperty{cha}{\l__cha_tl}{10}
	
	\RpgStatAddProperty{proficiency-bonus}{\g__rpg_proficiency_bonus_int}{2}
	
	\RpgStatAddBoolean{str-save}{\l__str_save_proficient_bool}
	\RpgStatAddBoolean{dex-save}{\l__dex_save_proficient_bool}
	\RpgStatAddBoolean{con-save}{\l__con_save_proficient_bool}
	\RpgStatAddBoolean{int-save}{\l__int_save_proficient_bool}
	\RpgStatAddBoolean{wis-save}{\l__wis_save_proficient_bool}
	\RpgStatAddBoolean{cha-save}{\l__cha_save_proficient_bool}
	
	\RpgStatAddProperty{skills}{\l__skills_tl}{}
	\RpgStatAddProperty{skills-expertise}{\l__skills_expertise_tl}{}
	
	\keys_define:nn { rpg / forge / statblock }
	{
	% 	%%Aliases
		ac 				.meta:n = { armor-class=#1},
		AC 				.meta:n = { armor-class=#1},
		hp 				.meta:n = { hit-points=#1},
		HP 				.meta:n = { hit-points=#1},
		STR 			.meta:n = { str = #1 },
		DEX 			.meta:n = { dex = #1 },
		CON 			.meta:n = { con = #1 },
		INT 			.meta:n = { int = #1 },
		WIS 			.meta:n = { wis = #1 },
		CHA 			.meta:n = { cha = #1 },
		proficiency 	.meta:n = { proficiency-bonus = #1} 
	}


	%% Stat details
	\keys_define:nn { rpg / stat / details }
	{
		skills .tl_set:N         = \l__skills_tl,
		skills .value_required:n = true,
		damage-vulnerabilities .tl_set:N         = \l__damage_vulnerabilities_tl,
		damage-vulnerabilities .value_required:n = true,
		damagevulnerabilities .meta:n = { damage-vulnerabilities = {#1} },
		damage-resistances .tl_set:N         = \l__damage_resistances_tl,
		damage-resistances .value_required:n = true,
		damageresistances .meta:n = { damage-resistances = {#1} },
		damage-immunities .tl_set:N         = \l__damage_immunities_tl,
		damage-immunities .value_required:n = true,
		damageimmunities .meta:n = { damage-immunities = {#1} },
		condition-immunities .tl_set:N         = \l__condition_immunities_tl,
		condition-immunities .value_required:n = true,
		conditionimmunities .meta:n = { condition-immunities = {#1} },
		condition-resistances .tl_set:N         = \l__condition_resistances_tl,
		condition-resistances .value_required:n = true,
		conditionresistances .meta:n = { condition-immunities = {#1} },
		senses .tl_set:N         = \l__senses_tl,
		senses .initial:n        = {},
		senses .value_required:n = true,
		languages .tl_set:N         = \l__languages_tl,
		languages .initial:n        = ---,
		languages .value_required:n = true,
		challenge .tl_set:N         = \l__challenge_tl,
		challenge .initial:n        = 1,
		challenge .value_required:n = true,
	}

	\tl_new:N \l__rpg_attack_distance_tl
	\tl_new:N \l__rpg_attack_type_tl
	\tl_new:N \l__attack_stat_tl
	\keys_define:nn { rpg / stat / attack }
	{
		distance .choice:,
		distance .choices:nn =
		{ both, melee, ranged }
		{ \tl_set:Nn \l__rpg_attack_distance_tl {\l_keys_choice_tl} },
		distance .initial:n  = both,
		type .choice:,
		type / weapon .code:n = { \tl_set:Nn \l__rpg_attack_type_tl {} },
		type / spell .code:n = { \tl_set:Nn \l__rpg_attack_type_tl {Spell~} },
		type .initial:n  = weapon,
		modifier .choice:,
		modifier / STR .code:n = {\tl_set:Nn \l__attack_stat_tl{str} },
		modifier / DEX .code:n = {\tl_set:Nn \l__attack_stat_tl{dex} },
		modifier / CON .code:n = {\tl_set:Nn \l__attack_stat_tl{con} },
		modifier / INT .code:n = {\tl_set:Nn \l__attack_stat_tl{int} },
		modifier / WIS .code:n = {\tl_set:Nn \l__attack_stat_tl{wis} },
		modifier / CHA .code:n = {\tl_set:Nn \l__attack_stat_tl{cha} },
        modifier .initial:n = {INT},
		bonus .int_set:N=\l__attack_bonus_int,
		bonus .initial:n = 0,
		reach .tl_set:N         = \l__reach_tl,
		reach .initial:n        = 5,
		reach .value_required:n = true,
		range .tl_set:N         = \l__range_tl,
		range .initial:n        = 20/60,
		range .value_required:n = true,
		dmg .tl_set:N         = \l__dmg_tl,
		dmg .value_required:n = true,
		dmg-type .tl_set:N         = \l__dmg_type_tl,
		dmg-type .value_required:n = true,
		plus-dmg .tl_set:N         = \l__plus_dmg_tl,
		plus-dmg .value_required:n = true,
		plus-dmg-type .tl_set:N         = \l__plus_dmg_type_tl,
		plus-dmg-type .value_required:n = true,
		or-dmg .tl_set:N         = \l__or_dmg_tl,
		or-dmg .value_required:n = true,
		or-dmg-when .tl_set:N         = \l__or_dmg_when_tl,
		or-dmg-when .value_required:n = true,
		extra .tl_set:N         = \l__extra_tl,
		extra .value_required:n = true,
	}

	\tl_new:N \l__spell_stat_tl
	\tl_new:N \l__spell_stat_nice_tl
	\bool_new:N \l__spells_nocomponents_bool
	\bool_new:N \l__spells_notext_bool
	% \bool_set_false:N \l__spells_nocomponents_bool
	\keys_define:nn { rpg / stat / spells }
	{
		spellcasting-name	.tl_set:N= \l__spell_list_name_tl,
		spellcasting-name .value_required:n = true,
		spellcasting-name .initial:n = {Spellcasting},
		modifier .choice:,
		modifier / STR .code:n = {\tl_set:Nn \l__spell_stat_tl{str} \tl_set:Nn \l__spell_stat_nice_tl{Strength}},
		modifier / DEX .code:n = {\tl_set:Nn \l__spell_stat_tl{dex} \tl_set:Nn \l__spell_stat_nice_tl{Dexterity}},
		modifier / CON .code:n = {\tl_set:Nn \l__spell_stat_tl{con} \tl_set:Nn \l__spell_stat_nice_tl{Constitution}},
		modifier / INT .code:n = {\tl_set:Nn \l__spell_stat_tl{int} \tl_set:Nn \l__spell_stat_nice_tl{Intelligence}},
		modifier / WIS .code:n = {\tl_set:Nn \l__spell_stat_tl{wis} \tl_set:Nn \l__spell_stat_nice_tl{Wisdom}},
		modifier / CHA .code:n = {\tl_set:Nn \l__spell_stat_tl{cha} \tl_set:Nn \l__spell_stat_nice_tl{Charisma}},
        modifier .initial:n = {INT},
		bonus .int_set:N=\l__spell_bonus_int,
		bonus .initial:n = 0,
		no-components .code:n = {\bool_set_true:N \l__spells_nocomponents_bool},
		no-components .value_forbidden:n = true,
		no-text .code:n = {\bool_set_true:N \l__spells_notext_bool},
		no-text .value_forbidden:n = true,
		notext .code:n = {\bool_set_true:N \l__spells_notext_bool},
		notext .value_forbidden:n = true,
	}
%%%%% Formatting functions
	%% These are the functions which do the actual nitty gritty of formatting the environments the user declared
	\cs_new_protected_nopar:Npn \__rpg_stat_basics:
	{
		{
			\color{titlered}
			\noindent\begin{tabularx}{\linewidth}{lXlX}
				\textbf{AC} & \l__armor_class_tl & \textbf{Speed} &  \l__speed_tl
				\\
				\textbf{HP} &  \l__hit_points_tl & \textbf{Initiative} &
				\bool_if:NTF \l__manual_initiative_bool
				{
					\l__initiative_bonus_tl
					}{
						\__rpg_format_signed_integer:N \l__dex_mod
					}
			\end{tabularx}
		}
	}

	\tl_new:N \l__processed_skills
	\seq_new:N \l__seq_holder
	\cs_new_protected:Npn \__rpg_stat_compute_skill_bonus:nn#1#2
	{
		\str_case:enF{\str_lowercase:n{#1}}
		{
			{athletics} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__str_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{acrobatics} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__dex_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{sleight~of~hand} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__dex_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{stealth} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__dex_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{arcana} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__int_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{history} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__int_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{investigation} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__int_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{nature} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__int_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{religion} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__int_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{animal~handling} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__wis_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{insight} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__wis_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{medicine} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__wis_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{perception} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__wis_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{survival} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__wis_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{deception} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__cha_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{intimidation} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__cha_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{performance} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__cha_mod+#2*\g__rpg_proficiency_bonus_int}}}
			{persuasion} {\__rpg_format_signed_integer:N{\fp_eval:n{\l__cha_mod+#2*\g__rpg_proficiency_bonus_int}}}
			

		}
		{
			0% \g__rpg_proficiency_bonus_int0
		}
	}
	\cs_new_protected:Npn \__rpg_stat_process_skills:
	{
		\seq_clear:N\l__seq_holder
		% \clist_set:Nx\l__cs_holder{\l__skills_tl}
		\clist_map_inline:Nn\l__skills_expertise_tl
		{
			\seq_put_right:Nn\l__seq_holder{\text_titlecase_all:n{##1}~(\__rpg_stat_compute_skill_bonus:nn{##1}{2})}
		}
		\clist_map_inline:Nn\l__skills_tl
		{
			\seq_put_right:Nn\l__seq_holder{\text_titlecase_all:n{##1}~(\__rpg_stat_compute_skill_bonus:nn{##1}{1})}
		}
		\tl_set:Nn{\l__processed_skills}{\seq_use:Nn{\l__seq_holder}{,~}}
		
	}

	\cs_new_protected_nopar:Npn \__rpg_stat_details:
	{
		\__rpg_stat_process_skills:
		\begin {__rpg_stat_attributes}
		\__rpg_if_stat_attribute:nn {\l__processed_skills}                 {Skills}
		\__rpg_if_stat_attribute:nn {\l__damage_vulnerabilities_tl} {Damage~Vulnerabilities}
		\__rpg_if_stat_attribute:nn {\l__damage_resistances_tl}     {Damage~Resistances}
		\__rpg_if_stat_attribute:nn {\l__damage_immunities_tl}      {Damage~Immunities}
		\__rpg_if_stat_attribute:nn {\l__condition_immunities_tl}   {Condition~Immunities}
		\__rpg_if_stat_attribute:nn {\l__condition_resistances_tl}   {Condition~Resistances}
		\item [Senses]    \l__senses_tl
		\item [Languages] \l__languages_tl
		\item [Challenge] \l__challenge_tl
		\end {__rpg_stat_attributes}
	}



	%%Formatters for ability table
		\cs_new:Npn \__rpg_format_mod_labels:n #1
		{
			\rotatebox[origin=c]{90}{\scriptsize \hspace{0.1cm} #1 \hspace{0.1cm}}
		}
		\cs_new:Npn \__rpg_format_stat_titles:nn #1#2
		{
			& \parbox[t]{1.25cm}{\centering \RpgFontStatBlockTitle  \footnotesize{#1} ~{ (#2)} }
		}
	
	\int_new:N\l__str_mod
	\int_new:N\l__dex_mod
	\int_new:N\l__con_mod
	\int_new:N\l__int_mod
	\int_new:N\l__wis_mod
	\int_new:N\l__cha_mod
	% \int_new:N\l__str_mod
	\cs_new_protected_nopar:Npn \__rpg_stat_compute_modifiers:
	{
		% \int_set:Nn \l__str_mod{\__rpg_ability_score_modifier:N{\l__dex_tl}}
		\__rpg_store_ability_score_modifier:NV{\l__str_mod}{\l__str_tl}
		\__rpg_store_ability_score_modifier:NV{\l__dex_mod}{\l__dex_tl}
		\__rpg_store_ability_score_modifier:NV{\l__con_mod}{\l__con_tl}
		\__rpg_store_ability_score_modifier:NV{\l__int_mod}{\l__int_tl}
		\__rpg_store_ability_score_modifier:NV{\l__wis_mod}{\l__wis_tl}
		\__rpg_store_ability_score_modifier:NV{\l__cha_mod}{\l__cha_tl}
	}

	% Ability scores in a table
	\cs_new_protected_nopar:Npn \__rpg_stat_ability_scores:
	{
		

		\vspace{-0.8em}

		\color {titlered}
		{
		% \addtolength{\tabcolsep}{-0.5em}
		\setlength\topsep{0pt}
		\setlength\tabcolsep{0pt}
		\noindent\begin{center}\maxsizebox{\linewidth}{!}{
		\noindent\begin{RpgTable}[simple]{rcccccc}
		~
		\__rpg_format_stat_titles:nn{STR}{\l__str_tl}
		\__rpg_format_stat_titles:nn{DEX}{\l__dex_tl}
		\__rpg_format_stat_titles:nn{CON}{\l__con_tl}
		\__rpg_format_stat_titles:nn{INT}{\l__int_tl}
		\__rpg_format_stat_titles:nn{WIS}{\l__wis_tl}
		\__rpg_format_stat_titles:nn{CHA}{\l__cha_tl}
		\\
		\__rpg_format_mod_labels:n{mod} &
		\__rpg_format_signed_integer:N{\l__str_mod} &
		\__rpg_format_signed_integer:N{\l__dex_mod} &
		\__rpg_format_signed_integer:N{\l__con_mod} &
		\__rpg_format_signed_integer:N{\l__int_mod} &
		\__rpg_format_signed_integer:N{\l__wis_mod} &
		\__rpg_format_signed_integer:N{\l__cha_mod}
		\\
		%if any proficiencies set, then render the save row
		\bool_lazy_any:nT {
			\l__str_save_proficient_bool
			\l__dex_save_proficient_bool
			\l__con_save_proficient_bool
			\l__int_save_proficient_bool
			\l__wis_save_proficient_bool
			\l__cha_save_proficient_bool
		}{
			\__rpg_format_mod_labels:n{save}&
			\__rpg_save_modifier:Nn \l__str_tl \l__str_save_proficient_bool &
			\__rpg_save_modifier:Nn \l__dex_tl \l__dex_save_proficient_bool &
			\__rpg_save_modifier:Nn \l__con_tl \l__con_save_proficient_bool &
			\__rpg_save_modifier:Nn \l__int_tl \l__int_save_proficient_bool &
			\__rpg_save_modifier:Nn \l__wis_tl \l__wis_save_proficient_bool &
			\__rpg_save_modifier:Nn \l__cha_tl \l__cha_save_proficient_bool
		}{}

		\end{RpgTable}
		}
		
	\end{center}
		}
		\par 
	}



%%%% User-facing functions

	% Utility
		% Fancy DnD 5e stat block rule
		\NewDocumentCommand {\RpgStatLine} {}
		{
			\par \vspace{-2pt} \noindent
			\begin {tikzpicture}
			\draw [ rulered, fill = rulered ] ( 0, 0 ) -- ( 0, 0.1 ) -- ( \linewidth, 0.05 );
			\end {tikzpicture}
			\par


		}

		\tl_new:N \l__rpg_stat_name
		%overwrites the internal macro
		\NewDocumentCommand\RpgSetStatName{m}
		{
			\tl_set:Nn \l__rpg_stat_name {#1}
		}

		\NewDocumentCommand\RpgStatName{}
		{
			\l__rpg_stat_name{}
		}

		\NewDocumentCommand \RpgSavingThrow { m m m m }
		{
			\textit{#1~Save,~DC~#2}.~\textbf{Failure:}~#3.
			\IfValueT {#4} {\textbf{~Success:}~#4}
		}

		\NewDocumentCommand\RpgRepeatableSavingThrow{O{The~target~can~repeat~the~save~at~the~end~of~each~turn.} m m m m}
		{
			\RpgSavingThrow{#2}{#3}{#4}{#5} \\ #1
		}

		\NewDocumentCommand\RpgStatReaction{m m m}
		{
			\RpgStatAction{#1} \textit{Trigger:} #2 \\ \textit{Response:} #3
		}

		\NewDocumentCommand\RpgLegendaryDefiance{}
		{
			\RpgStatLegendaryAction{Legendary~Defiance}~{At~the~end~of~another~creature's~turn,~\RpgStatName{}~chooses~to~repeat~a~saving~throw~that~they~failed~in~the~past~hour~(using~their~original~modifier).}
		}



	%%Core stat environments
		% Italicized text appearing immediately after stat's name
		\NewDocumentCommand {\RpgStatType} {m}
		{
			\begin {hangingpar}
			\textit {#1}
			\end {hangingpar}
		}

		%%Formats Speed, hp, ability scores etc
		\NewDocumentCommand {\RpgStatBasics} {O{}}
		{
			\__rpg_stat_compute_modifiers:
			%%deliberately not wrapped in a group because we want these variables to expose to other sections!
			\keys_set:nn { rpg / stat / basics } {#1}
			\RpgStatLine
			\__rpg_stat_basics:
			\RpgStatLine
			\__rpg_stat_ability_scores:
			\RpgStatLine
			\__rpg_stat_details:

			% (\g__rpg_proficiency_bonus_int)
		}

		%% Resistances, langages etc.
		\NewDocumentCommand {\RpgStatDetails} {o}
		{
			\group_begin:
				\keys_set:nn { rpg / stat / details } {#1}
				\RpgStatLine{}
				\__rpg_stat_details:
				\RpgStatLine{}
			\group_end:

		}

		% Stat subsection header style
		\NewDocumentCommand {\RpgStatSection} {m}
		{
			\addvspace{6pt plus 2pt minus 2pt} \noindent
			\group_begin:
			\RpgFontStatBlockSection #1\nopagebreak[4]
			\vspace {2pt}\nopagebreak[4]
			\hrule height 0.6pt
			\group_end:
			\par \ignorespaces\nopagebreak[4]
			\vspace {5pt}\nopagebreak[4]
		}

		% Inline header for stat actions - similar to a paragraph
		\NewDocumentCommand {\RpgStatAction} {m}
		{ \par \smallskip \noindent \textsl { \textbf {#1.} } }

		% Inline header for stat sub actions - similar to a subparagraph
		\NewDocumentCommand {\RpgStatSubAction} {m}
		{ \par \textsl { \textbf {#1.} } }

%%%%%% Spellcasting

	\newlist {__rpg_spell_block} {description} {1}
	\setlist [__rpg_spell_block]
	{
		font     = \normalfont \RpgFontStatBlockBody,
		labelsep = \l__rpg_space_dim,
		noitemsep,
		topsep   = 5pt plus 2pt minus 2pt,
	}

	\NewDocumentEnvironment{RpgStatSpells}{O{}}
	{
		\group_begin:
			\keys_set:nn { rpg / stat / spells } {#1}
			\bool_if:NF {\l__spells_notext_bool}
			{
				\__rpg_get_ability_mod:Nn {\l__spell_stat_tl}{\g__rpg_proficiency_bonus_int+\l__spell_bonus_int}

				\RpgStatAction{\l__spell_list_name_tl} ~{Save~DC~\fp_eval:n {8+\l__ability_modifier_int},~\__rpg_format_signed_integer:N {\l__ability_modifier_int}~to~hit}.\newline\RpgStatName{}~can~cast~the ~following~spells~using~\l__spell_stat_nice_tl{}
				\bool_if:NT \l__spells_nocomponents_bool
				{
					,~requiring~no~material~components
				}
				:
			}
			\begin{__rpg_spell_block}
	}
	{
			\end{__rpg_spell_block}
		\group_end:
	}

	%general wrapper for printing all spells in a list, with nice parsing of commans and whitespace
	\NewDocumentCommand {\RpgEmphSpellString} {m}
	{
		\group_begin:
		\seq_set_from_clist:Nn \l_tmpa_seq {#1}
		\seq_set_map:NNn \l_tmpb_seq \l_tmpa_seq { \exp_not:n { \it {##1} } }
		\seq_use:Nn \l_tmpb_seq { ,~ }
		\group_end:
	}

	\NewDocumentCommand {\RpgSpellList} { O {At~will} m }
	{
		\item
		[
			\regex_match:NnTF \c__pos_int_regex {#1} %checks it's a positive integer (no -2.4 times per day!)
			{
			\str_if_in:NnTF {#2} {,} %checks if there's one or more elements in list
			{ #1/day~each }
			{ #1/day}
			}
			{#1}
			:
		]
		\RpgEmphSpellString {#2}
	}

	%%New design paradigm has moved away from spell slots on stats, but this is here for consistency
	\NewDocumentCommand {\RpgStatSpellSlots} { o o m }
  {
    \item
      [
		\IfNoValueTF{#1}{
			Cantrips
		}
		{
			\RpgOrdinal{#1}~level
		}

        {~}(
        \IfNoValueTF{#2}{
			at~will
		}
		{
			\RpgPlural{#2}{slot}
		}
        ) :
      ]
    \RpgEmphSpellString{#3}
  }

%%%%%% Attacks

	%%Wrapper & formatters
		\cs_new_protected:Npn \__rpg_stat_reach:
		{
			\l__reach_tl\ ft
		}

		\cs_new_protected:Npn \__rpg_stat_range:
		{
			\l__range_tl\ ft
		}

		\cs_new_protected:Npn \__rpg_if_plus_dmg:
		{
			\tl_if_empty:NF {\l__plus_dmg_tl}
			{ ~ plus\ \l__plus_dmg_tl\ \l__plus_dmg_type_tl\ damage }
		}

		\cs_new_protected_nopar:Npn \__rpg_if_or_dmg:
		{
			\tl_if_empty:NF {\l__or_dmg_tl}
			{
			, ~ or\ \l__or_dmg_tl\ \l__dmg_type_tl\ damage\ \l__or_dmg_when_tl

			\tl_if_empty:NF {\l__plus_dmg_tl}
				{,}
			}
		}

	%%Main complex print function


		\cs_new_protected:Npn \__rpg_stat_attack:N #1
		{
			\__rpg_check_for_key:Nnn \l__attack_stat_tl {\RpgStatAttack} {mod}

			\begin{RpgStatAction} {#1}~
			\__rpg_get_ability_mod:Nn {\l__attack_stat_tl}{\g__rpg_proficiency_bonus_int+\l__attack_bonus_int}

			\str_case_e:nnF {\l__rpg_attack_distance_tl}
				{
				{ melee }
					{
					\textit{ Melee~\l__rpg_attack_type_tl{}(\__rpg_stat_reach:): } ~ \__rpg_format_signed_integer:N {\l__ability_modifier_int}~to~hit
					}
				{ ranged }
					{
					\textit{Ranged~\l__rpg_attack_type_tl{}(\__rpg_stat_range:):} ~ \__rpg_format_signed_integer:N {\l__ability_modifier_int}~to~hit
					}
				}
				{% Melee and Ranged is the default
				\textit{Melee~or~Ranged~\l__rpg_attack_type_tl{}(\__rpg_stat_reach:\ or\ \__rpg_stat_range:): } ~  \__rpg_format_signed_integer:N {\l__ability_modifier_int}~to~hit
				}
			. ~
			\textit { On~Hit : } ~

			\str_if_empty:NF {\l__dmg_tl} % Don't show any damage if `dmg' is not set.
				{
				\l__dmg_tl\ \l__dmg_type_tl\ damage
				\__rpg_if_or_dmg:
				\__rpg_if_plus_dmg:
				}

			% `extra' is any special text that goes after the final damage; do not
			% include the final full stop.
			\l__extra_tl .
			\end{RpgStatAction}
		}

	%%User interface
		\NewDocumentCommand {\RpgStatAttack} {o m}
		{
			\group_begin:
			\keys_set:nn { rpg / stat / attack } {#1}
			\__rpg_stat_attack:N {#2}
			\group_end:
		}

		\NewDocumentCommand {\RpgStatMelee} {o m}
		{
			\group_begin:
			\keys_set:nn { rpg / stat / attack } { #1, distance = melee }
			\__rpg_stat_attack:N {#2}
			\group_end:
		}

		\NewDocumentCommand {\RpgStatRanged} {o m}
		{
			\group_begin:
			\keys_set:nn { rpg / stat / attack } { #1, distance = ranged }
			\__rpg_stat_attack:N {#2}
			\group_end:
		}

%%%%%% Legendary Actions


	\newlist {__rpg_legendary} {description} {1}
	\setlist [__rpg_legendary]
	{
		font     = \RpgFontStatBlockBody,
		labelsep = \l__rpg_space_dim,
		noitemsep,
		topsep   = 6pt plus 2pt minus 2pt,
	}


	\NewDocumentEnvironment{RpgStatLegendaryActions}{ O{} +b}
		{
			\RpgStatSection{Legendary~Actions}
			\str_if_empty:NF #1
			{
				\RpgStatName{}~can~take~\textbf{#1}~legendary~actions.~Only~one~legendary~action~option~can~be~used~at~a~time~and~only~at~the~end~of~another~creature's~turn.~\RpgStatName{}~regains~spent~legendary~actions~at~the~start~of~its~turn.
			}
			\begin{__rpg_legendary}
				#2
		}{
			\end{__rpg_legendary}
		}

	\NewDocumentCommand {\RpgStatLegendaryAction} {O{} m m }
	{
		\item [ #2 \str_if_empty:NF#1{~(\textbf{#1~actions})}. ] #3
	}



