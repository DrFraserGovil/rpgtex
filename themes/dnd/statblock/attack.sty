
%%%%%% Attacks
\ExplSyntaxOn

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Attacks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	%% Options

	\__rpg_add_tl_keys:Nn{rpg/stat/attack}
	{
		\__rpg_tl_choice_key:nnnn{distance}{\l__rpg_attack_distance_tl}
						{ both , melee , ranged }{both}
		\__rpg_varying_choice_key:nnnn{type}{\l__rpg_attack_type_tl}{weapon,spell}{{},{~Spell}}{weapon}
		\__rpg_tl_choice_key:nnnn{modifier}{\l__attack_stat_tl}
						{ str , dex , con , int , wis , cha}{str}
		\__rpg_varying_choice_key:nnnn{modifier}{\l__attack_stat_tl}
						{STR , DEX , CON , INT , WIS , CHA}
						{str , dex , con , int , wis , cha}{str}
		\__rpg_tl_key:nnn{bonus}			{\l__bonus_int}		{0}
		\__rpg_tl_key:nnn{reach}			{\l__reach_tl}		{5}
		\__rpg_tl_key:nnn{range}			{\l__range_tl}		{20/60}
		\__rpg_tl_key:nnn{dmg}				{\l__dmg_tl}		{\RpgDice{1d4}}
		\__rpg_tl_key:nnn{dmg-type}			{\l__dmg_type_tl}	{bludgeoning}
		\__rpg_tl_key:nnn{plus-dmg}			{\l__plus_dmg_tl}	{}
		\__rpg_tl_key:nnn{plus-dmg-type}	{\l__plus_dmg_type_tl}{}
		\__rpg_tl_key:nnn{or-dmg}			{\l__or_dmg_tl}		{}
		\__rpg_tl_key:nnn{or-dmg-type}		{\l__or_dmg_type_tl}{}
		\__rpg_tl_key:nnn{or-dmg-when}		{\l__or_dmg_tl}		{}
		\__rpg_tl_key:nnn{extra}			{\l__extra_tl}		{}
	}

	%%Formatters

	\cs_new_protected:Npn \__rpg_if_plus_dmg:
	{
		\tl_if_empty:NF {\l__plus_dmg_tl}
		{ ~ plus\ \l__plus_dmg_tl\ \l__plus_dmg_type_tl\ damage }
	}

	\cs_new_protected_nopar:Npn \__rpg_if_or_dmg:
	{
		\tl_if_empty:NF {\l__or_dmg_tl}
		{
		, ~ or\ \l__or_dmg_tl\ \l__dmg_type_tl\ damage\ \l__or_dmg_when_tl

		\tl_if_empty:NF {\l__plus_dmg_tl}
			{,}
		}
	}

	\cs_new_protected_nopar:Npn \__rpg_make_modifier:nnn#1#2#3
	{
		\tl_set:Ne#1{\__rpg_format_signed_integer:N{\int_eval:n{\g__rpg_proficiency_bonus_int+#3+\use:c{l__#2 _mod}}}}
	}

	%%% Construct the `on hit' text
	\cs_new_protected:Npn \__rpg_on_hit_text:
	{
		\tl_clear:N\l_tmpa_tl
		\str_if_empty:NF {\l__dmg_tl}
			{
				\tl_set:Ne\l_tmpa_tl{
					\RpgDice{\l__dmg_tl}\ \l__dmg_type_tl\ damage
					\__rpg_if_or_dmg:
					\__rpg_if_plus_dmg:
					.\ 
				}
			}
		% `extra' is any special text that goes after the final damage; do not
		% include the final full stop.
		\str_if_empty:NF {\l__extra_tl}
			{
				\tl_set:Ne\l_tmpa_tl{\l_tmpa_tl\l__extra_tl .}
			}
		
		%%now place the output into the stream 	
		\l_tmpa_tl	
	}

	%%Attack function

	%% Formats the attack into the standard form:
	%% Melee/Ranged (distance-in-ft): +x to hit. On hit [damage-calculation] damage, [optional plus] [optional or]. 
	\NewDocumentCommand {\RpgStatAttack} {m O{}}
	{
		\group_begin:
		\keys_set:nn { rpg / stat / attack } {#2}
		%%format the reach/range strings into the desired form
		\__rpg_append_if_missing:nn{\l__reach_tl}{ft}
		\__rpg_append_if_missing:nn{\l__range_tl}{ft}

		%Compute the to-hit modifier
		\__rpg_make_modifier:nnn{\l__ability_modifier_int}{\l__attack_stat_tl}{\l__bonus_int}

		%%Typeset the main attack
		\RpgStatAction{#1}~
		
			\str_case_e:nn {\l__rpg_attack_distance_tl}
				{
					{ melee }   {\textit{Melee\l__rpg_attack_type_tl{}~(\l__reach_tl):}~}
					{ ranged }  {\textit{Ranged\l__rpg_attack_type_tl{}~(\l__range_tl):}~}
					{ both }    {\textit{Melee~(\l__reach_tl)\ or\ Ranged~(\l__range_tl)\l__rpg_attack_type_tl :}~} 
				}

		{\l__ability_modifier_int}~to~hit.\ 

		\tl_set:Nn\l_tmpa_tl{\__rpg_on_hit_text:}		
		\str_if_empty:NF {\l_tmpa_tl}
			{
				\textit { On~Hit : } ~ \l_tmpa_tl
			}
		\group_end:
	}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Spells
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\__rpg_add_tl_keys:Nn{rpg/stat/spell}
	{
		\__rpg_tl_key:nnn{title}{\l__spell_title_tl}{Spellcasting}
		\__rpg_tl_choice_key:nnnn{modifier}{\l__spell_stat_tl}{str,dex,con,int,wis,cha}{int}	
		\__rpg_tl_key:nnn{bonus}{\l__spell_bonus_int}{0}
		\__rpg_bool_key:nn{innate}{\l__spell_innate_bool}
		\__rpg_bool_key:nn{list-only}{\l__spell_list_only}
	}

	\NewDocumentEnvironment{RpgStatSpellcasting}{O{}}{
		\group_begin:
		\keys_set:nn { rpg / stat / spells } {#1}
	
		\__rpg_make_modifier:nnn{\l__ability_modifier_int}{\l__spell_stat_tl}{\l__spell_bonus_int}
		\tl_set:Ne \l__save_int{\fp_eval:n{8+\l__ability_modifier_int}}
		\tl_set:Ne \l__nice_stat{\prop_item:Ne{\g__dnd_stats_names}{\l__spell_stat_tl}}

		\RpgStatAction{\l__spell_title_tl}~Save\ DC\ \l__save_int,~\l__ability_modifier_int\ to\ hit.\ \name{}\ can\ cast\ the\ following\ spells\ using\ their\ \l__nice_stat
		\bool_if:NT{\l__spell_innate_bool}
		{
			,\ requiring\ no\ material\ components
		}
		:

		\providecommand{\spell}{\RpgStatSpellList}
		\providecommand{\slot}{\RpgStatSpellSlots}
		\begin{description}
			[
			font     = \normalfont \RpgFontStatBlockBody,
			labelsep = \l__rpg_space_dim,
			itemindent=0.5em,
			noitemsep,
			topsep   = 5pt plus 2pt minus 2pt,
		]
	}
	{
		\end{description}
		\group_end:
	}

	%general wrapper for printing all spells in a list, with nice parsing of commans and whitespace
	\NewDocumentCommand {\RpgEmphSpellString} {m}
	{
		\group_begin:
		\seq_set_from_clist:Nn \l_tmpa_seq {#1}
		\seq_set_map:NNn \l_tmpb_seq \l_tmpa_seq { \exp_not:n { \it {##1} } }
		\seq_use:Nn \l_tmpb_seq { ,~ }
		\group_end:
	}

	\NewDocumentCommand {\RpgStatSpellList} { O {At~will} m }
	{
		\item
		[
			\regex_match:NnTF \c__pos_int_regex {#1} %checks it's a positive integer (no -2.4 times per day!)
			{
			\str_if_in:NnTF {#2} {,} %checks if there's one or more elements in list
			{ #1/day~each }
			{ #1/day}
			}
			{#1}
			:
		]
		\RpgEmphSpellString {#2}
	}

	%%New design paradigm has moved away from spell slots on stats, but this is here for consistency
	\NewDocumentCommand {\RpgStatSpellSlots} { o o m }
  {
    \item
      [
		\IfNoValueTF{#1}{
			Cantrips
		}
		{
			\RpgOrdinal{#1}~level
		}

        {~}(
        \IfNoValueTF{#2}{
			at~will
		}
		{
			\RpgPlural{#2}{slot}
		}
        ) :
      ]
    \RpgEmphSpellString{#3}
  }