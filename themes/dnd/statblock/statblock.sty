\ExplSyntaxOn



%%%%%% RpgStat Environment

	
	\RpgStatTextFormat{

		%%initial value processing
		\RpgSetStatName{#1} %make #the stat's name accessible via macro so stat blocks can easily change names
		\__rpg_stat_preprocessing:

		%%begin the box
		\rpg_stat_box:n{}
			
			\RpgStatTitle{#1}

			
			\RpgHeaderBlock{}

				#2
		\end{RpgStatBox}
	}

	\RpgStatCardFormat{
		
		\subsection{#1}
			#2
	}
	

	% %%Starred version is a floating, two column version used for boss stats
	% %%Takes two sets of optional arguments: one to the float, one to the tcolorbox
	% \NewDocumentEnvironment {RpgStat*} { O{} O{} m +b}
	% {
	% 	\begin{figure*}[#1]
	% 	\centering
	% 	\rpg_stat_box:nn {#2} {#3}

	% 	\vspace{-1em}
	% 	\begin{multicols}{2}
	% 	#4
	% }
	% {
	% 	\end{multicols}
	% 	\end{RpgStatBox}
	% 	\end{figure*}
	% }


	%%Begins the environment with different arguments depending on print mode
	\NewDocumentCommand \rpg_stat_box:n { m }
	{
		
		\bool_if:NTF \l__rpg_show_background_bool
		{
			\begin{RpgStatBox}[#1]{}
		}
		{
			\begin{RpgStatBox}[#1,colback=white,colframe=black!30!white]{}
		}
		
	}


%%%%%% Internal Helper functions
			
	\int_new:N \l__ability_modifier_int
	\int_set:Nn \l__ability_modifier_int {0}
	\cs_new:Npn \__rpg_get_ability_mod:Nn #1#2
	{
		%%retrieve ability scores based on string names
		% \group_begin:
		\tl_set:Nn \l_tmpa_tl { \tl_use:N #1 }
		\tl_set:Nn \l_tmpb_tl { l__\l_tmpa_tl _tl }
		\cs_if_exist:cTF { \l_tmpb_tl }
		{
			\int_set:Nn \l__ability_modifier_int { \fp_eval:n {#2 + floor ( ( \tl_use:c{ \l_tmpb_tl } - 10 ) / 2 ) } }
			% \int_set:Nn \l_tmpa_int { \fp_eval:n { floor ( ( \tl_use:c{ \l_tmpb_tl } - 10 ) / 2 ) } }
			% \exp_args:Nf \l_tmpa_int
		}
		{
			\msg_set:nnnn { rpg } { bad-modifier } { #1~expands~to~\l_tmpa_tl} { looong }
			\msg_error:nnnn { rpg } { bad-modifier }
			+0
		}

    % \group_end:
}
%%%%%% Variable definitions

	%% This is a big long keyval section, there's no real way to make it pretty

				


	\tl_new:N \l__rpg_attack_distance_tl
	\tl_new:N \l__rpg_attack_type_tl
	\tl_new:N \l__attack_stat_tl
	\keys_define:nn { rpg / stat / attack }
	{
		distance .choice:,
		distance .choices:nn =
		{ both, melee, ranged }
		{ \tl_set:Nn \l__rpg_attack_distance_tl {\l_keys_choice_tl} },
		distance .initial:n  = both,
		type .choice:,
		type / weapon .code:n = { \tl_set:Nn \l__rpg_attack_type_tl {} },
		type / spell .code:n = { \tl_set:Nn \l__rpg_attack_type_tl {Spell~} },
		type .initial:n  = weapon,
		modifier .choice:,
		modifier / STR .code:n = {\tl_set:Nn \l__attack_stat_tl{str} },
		modifier / DEX .code:n = {\tl_set:Nn \l__attack_stat_tl{dex} },
		modifier / CON .code:n = {\tl_set:Nn \l__attack_stat_tl{con} },
		modifier / INT .code:n = {\tl_set:Nn \l__attack_stat_tl{int} },
		modifier / WIS .code:n = {\tl_set:Nn \l__attack_stat_tl{wis} },
		modifier / CHA .code:n = {\tl_set:Nn \l__attack_stat_tl{cha} },
        modifier .initial:n = {INT},
		bonus .int_set:N=\l__attack_bonus_int,
		bonus .initial:n = 0,
		reach .tl_set:N         = \l__reach_tl,
		reach .initial:n        = 5,
		reach .value_required:n = true,
		range .tl_set:N         = \l__range_tl,
		range .initial:n        = 20/60,
		range .value_required:n = true,
		dmg .tl_set:N         = \l__dmg_tl,
		dmg .value_required:n = true,
		dmg-type .tl_set:N         = \l__dmg_type_tl,
		dmg-type .value_required:n = true,
		plus-dmg .tl_set:N         = \l__plus_dmg_tl,
		plus-dmg .value_required:n = true,
		plus-dmg-type .tl_set:N         = \l__plus_dmg_type_tl,
		plus-dmg-type .value_required:n = true,
		or-dmg .tl_set:N         = \l__or_dmg_tl,
		or-dmg .value_required:n = true,
		or-dmg-when .tl_set:N         = \l__or_dmg_when_tl,
		or-dmg-when .value_required:n = true,
		extra .tl_set:N         = \l__extra_tl,
		extra .value_required:n = true,
	}

	\tl_new:N \l__spell_stat_tl
	\tl_new:N \l__spell_stat_nice_tl
	\bool_new:N \l__spells_nocomponents_bool
	\bool_new:N \l__spells_notext_bool
	% \bool_set_false:N \l__spells_nocomponents_bool
	\keys_define:nn { rpg / stat / spells }
	{
		spellcasting-name	.tl_set:N= \l__spell_list_name_tl,
		spellcasting-name .value_required:n = true,
		spellcasting-name .initial:n = {Spellcasting},
		modifier .choice:,
		modifier / STR .code:n = {\tl_set:Nn \l__spell_stat_tl{str} \tl_set:Nn \l__spell_stat_nice_tl{Strength}},
		modifier / DEX .code:n = {\tl_set:Nn \l__spell_stat_tl{dex} \tl_set:Nn \l__spell_stat_nice_tl{Dexterity}},
		modifier / CON .code:n = {\tl_set:Nn \l__spell_stat_tl{con} \tl_set:Nn \l__spell_stat_nice_tl{Constitution}},
		modifier / INT .code:n = {\tl_set:Nn \l__spell_stat_tl{int} \tl_set:Nn \l__spell_stat_nice_tl{Intelligence}},
		modifier / WIS .code:n = {\tl_set:Nn \l__spell_stat_tl{wis} \tl_set:Nn \l__spell_stat_nice_tl{Wisdom}},
		modifier / CHA .code:n = {\tl_set:Nn \l__spell_stat_tl{cha} \tl_set:Nn \l__spell_stat_nice_tl{Charisma}},
        modifier .initial:n = {INT},
		bonus .int_set:N=\l__spell_bonus_int,
		bonus .initial:n = 0,
		no-components .code:n = {\bool_set_true:N \l__spells_nocomponents_bool},
		no-components .value_forbidden:n = true,
		no-text .code:n = {\bool_set_true:N \l__spells_notext_bool},
		no-text .value_forbidden:n = true,
		notext .code:n = {\bool_set_true:N \l__spells_notext_bool},
		notext .value_forbidden:n = true,
	}
%%%%% Formatting functions
	%% These are the functions which do the actual nitty gritty of formatting the environments the user declared
	

	

	


	%%Formatters for ability table
		\cs_new:Npn \__rpg_format_mod_labels:n #1
		{
			\rotatebox[origin=c]{90}{\scriptsize \hspace{0.1cm} #1 \hspace{0.1cm}}
		}
		\cs_new:Npn \__rpg_format_stat_titles:nn #1#2
		{
			& \parbox[t]{1.25cm}{\centering \RpgFontStatBlockTitle  \footnotesize{#1} ~{ (#2)} }
		}
	
	

	% Ability scores in a table
	\cs_new_protected_nopar:Npn \__rpg_stat_ability_scores:
	{
		

		\vspace{-0.8em}

		\color {titlered}
		{
		% \addtolength{\tabcolsep}{-0.5em}
		\setlength\topsep{0pt}
		\setlength\tabcolsep{0pt}
		\noindent\begin{center}\maxsizebox{\linewidth}{!}{
		\noindent\begin{RpgTable}[simple]{rcccccc}
		~
		\__rpg_format_stat_titles:nn{STR}{\l__str_tl}
		\__rpg_format_stat_titles:nn{DEX}{\l__dex_tl}
		\__rpg_format_stat_titles:nn{CON}{\l__con_tl}
		\__rpg_format_stat_titles:nn{INT}{\l__int_tl}
		\__rpg_format_stat_titles:nn{WIS}{\l__wis_tl}
		\__rpg_format_stat_titles:nn{CHA}{\l__cha_tl}
		\\
		\__rpg_format_mod_labels:n{mod} &
		\__rpg_format_signed_integer:N{\l__str_mod} &
		\__rpg_format_signed_integer:N{\l__dex_mod} &
		\__rpg_format_signed_integer:N{\l__con_mod} &
		\__rpg_format_signed_integer:N{\l__int_mod} &
		\__rpg_format_signed_integer:N{\l__wis_mod} &
		\__rpg_format_signed_integer:N{\l__cha_mod}
		\\
		%if any proficiencies set, then render the save row
		
		\__rpg_if_any_saves:T
		{
			\__rpg_format_mod_labels:n{save}
			\seq_map_inline:Nn{\g__dnd_stats}
			{
				& \tl_use:c{l__##1_save} 	
			}
		}

		\end{RpgTable}
		}
		
	\end{center}
		}
		\par 
	}



%%%% User-facing functions

	% Utility
		

		\tl_new:N \l__rpg_stat_name
		%overwrites the internal macro
		\NewDocumentCommand\RpgSetStatName{m}
		{
			\tl_set:Nn \l__rpg_stat_name {#1}
		}

		\NewDocumentCommand\RpgStatName{}
		{
			\l__rpg_stat_name{}
		}

		\NewDocumentCommand \RpgSavingThrow { m m m m }
		{
			\textit{#1~Save,~DC~#2}.~\textbf{Failure:}~#3.
			\IfValueT {#4} {\textbf{~Success:}~#4}
		}

		\NewDocumentCommand\RpgRepeatableSavingThrow{O{The~target~can~repeat~the~save~at~the~end~of~each~turn.} m m m m}
		{
			\RpgSavingThrow{#2}{#3}{#4}{#5} \\ #1
		}

		\NewDocumentCommand\RpgStatReaction{m m m}
		{
			\RpgStatAction{#1} \textit{Trigger:} #2 \\ \textit{Response:} #3
		}

		\NewDocumentCommand\RpgLegendaryDefiance{}
		{
			\RpgStatLegendaryAction{Legendary~Defiance}~{At~the~end~of~another~creature's~turn,~\RpgStatName{}~chooses~to~repeat~a~saving~throw~that~they~failed~in~the~past~hour~(using~their~original~modifier).}
		}



	
		

		% Inline header for stat actions - similar to a paragraph
		\NewDocumentCommand {\RpgStatAction} {m}
		{ \par \smallskip \noindent \textsl { \textbf {#1.} } }

		% Inline header for stat sub actions - similar to a subparagraph
		\NewDocumentCommand {\RpgStatSubAction} {m}
		{ \par \textsl { \textbf {#1.} } }

%%%%%% Spellcasting

	\newlist {__rpg_spell_block} {description} {1}
	\setlist [__rpg_spell_block]
	{
		font     = \normalfont \RpgFontStatBlockBody,
		labelsep = \l__rpg_space_dim,
		noitemsep,
		topsep   = 5pt plus 2pt minus 2pt,
	}

	\NewDocumentEnvironment{RpgStatSpells}{O{}}
	{
		\group_begin:
			\keys_set:nn { rpg / stat / spells } {#1}
			\bool_if:NF {\l__spells_notext_bool}
			{
				\__rpg_get_ability_mod:Nn {\l__spell_stat_tl}{\g__rpg_proficiency_bonus_int+\l__spell_bonus_int}

				\RpgStatAction{\l__spell_list_name_tl} ~{Save~DC~\fp_eval:n {8+\l__ability_modifier_int},~\__rpg_format_signed_integer:N {\l__ability_modifier_int}~to~hit}.\newline\RpgStatName{}~can~cast~the ~following~spells~using~\l__spell_stat_nice_tl{}
				\bool_if:NT \l__spells_nocomponents_bool
				{
					,~requiring~no~material~components
				}
				:
			}
			\begin{__rpg_spell_block}
	}
	{
			\end{__rpg_spell_block}
		\group_end:
	}

	%general wrapper for printing all spells in a list, with nice parsing of commans and whitespace
	\NewDocumentCommand {\RpgEmphSpellString} {m}
	{
		\group_begin:
		\seq_set_from_clist:Nn \l_tmpa_seq {#1}
		\seq_set_map:NNn \l_tmpb_seq \l_tmpa_seq { \exp_not:n { \it {##1} } }
		\seq_use:Nn \l_tmpb_seq { ,~ }
		\group_end:
	}

	\NewDocumentCommand {\RpgSpellList} { O {At~will} m }
	{
		\item
		[
			\regex_match:NnTF \c__pos_int_regex {#1} %checks it's a positive integer (no -2.4 times per day!)
			{
			\str_if_in:NnTF {#2} {,} %checks if there's one or more elements in list
			{ #1/day~each }
			{ #1/day}
			}
			{#1}
			:
		]
		\RpgEmphSpellString {#2}
	}

	%%New design paradigm has moved away from spell slots on stats, but this is here for consistency
	\NewDocumentCommand {\RpgStatSpellSlots} { o o m }
  {
    \item
      [
		\IfNoValueTF{#1}{
			Cantrips
		}
		{
			\RpgOrdinal{#1}~level
		}

        {~}(
        \IfNoValueTF{#2}{
			at~will
		}
		{
			\RpgPlural{#2}{slot}
		}
        ) :
      ]
    \RpgEmphSpellString{#3}
  }

%%%%%% Attacks

	%%Wrapper & formatters
		\cs_new_protected:Npn \__rpg_stat_reach:
		{
			\l__reach_tl\ ft
		}

		\cs_new_protected:Npn \__rpg_stat_range:
		{
			\l__range_tl\ ft
		}

		\cs_new_protected:Npn \__rpg_if_plus_dmg:
		{
			\tl_if_empty:NF {\l__plus_dmg_tl}
			{ ~ plus\ \l__plus_dmg_tl\ \l__plus_dmg_type_tl\ damage }
		}

		\cs_new_protected_nopar:Npn \__rpg_if_or_dmg:
		{
			\tl_if_empty:NF {\l__or_dmg_tl}
			{
			, ~ or\ \l__or_dmg_tl\ \l__dmg_type_tl\ damage\ \l__or_dmg_when_tl

			\tl_if_empty:NF {\l__plus_dmg_tl}
				{,}
			}
		}

	%%Main complex print function


		\cs_new_protected:Npn \__rpg_stat_attack:N #1
		{
			\__rpg_check_for_key:Nnn \l__attack_stat_tl {\RpgStatAttack} {mod}

			\begin{RpgStatAction} {#1}~
			\__rpg_get_ability_mod:Nn {\l__attack_stat_tl}{\g__rpg_proficiency_bonus_int+\l__attack_bonus_int}

			\str_case_e:nnF {\l__rpg_attack_distance_tl}
				{
				{ melee }
					{
					\textit{ Melee~\l__rpg_attack_type_tl{}(\__rpg_stat_reach:): } ~ \__rpg_format_signed_integer:N {\l__ability_modifier_int}~to~hit
					}
				{ ranged }
					{
					\textit{Ranged~\l__rpg_attack_type_tl{}(\__rpg_stat_range:):} ~ \__rpg_format_signed_integer:N {\l__ability_modifier_int}~to~hit
					}
				}
				{% Melee and Ranged is the default
				\textit{Melee~or~Ranged~\l__rpg_attack_type_tl{}(\__rpg_stat_reach:\ or\ \__rpg_stat_range:): } ~  \__rpg_format_signed_integer:N {\l__ability_modifier_int}~to~hit
				}
			. ~
			\textit { On~Hit : } ~

			\str_if_empty:NF {\l__dmg_tl} % Don't show any damage if `dmg' is not set.
				{
				\l__dmg_tl\ \l__dmg_type_tl\ damage
				\__rpg_if_or_dmg:
				\__rpg_if_plus_dmg:
				}

			% `extra' is any special text that goes after the final damage; do not
			% include the final full stop.
			\l__extra_tl .
			\end{RpgStatAction}
		}

	%%User interface
		\NewDocumentCommand {\RpgStatAttack} {o m}
		{
			\group_begin:
			\keys_set:nn { rpg / stat / attack } {#1}
			\__rpg_stat_attack:N {#2}
			\group_end:
		}

		\NewDocumentCommand {\RpgStatMelee} {o m}
		{
			\group_begin:
			\keys_set:nn { rpg / stat / attack } { #1, distance = melee }
			\__rpg_stat_attack:N {#2}
			\group_end:
		}

		\NewDocumentCommand {\RpgStatRanged} {o m}
		{
			\group_begin:
			\keys_set:nn { rpg / stat / attack } { #1, distance = ranged }
			\__rpg_stat_attack:N {#2}
			\group_end:
		}

%%%%%% Legendary Actions


	\newlist {__rpg_legendary} {description} {1}
	\setlist [__rpg_legendary]
	{
		font     = \RpgFontStatBlockBody,
		labelsep = \l__rpg_space_dim,
		noitemsep,
		topsep   = 6pt plus 2pt minus 2pt,
	}


	\NewDocumentEnvironment{RpgStatLegendaryActions}{ O{} +b}
		{
			\RpgStatSection{Legendary~Actions}
			\str_if_empty:NF #1
			{
				\RpgStatName{}~can~take~\textbf{#1}~legendary~actions.~Only~one~legendary~action~option~can~be~used~at~a~time~and~only~at~the~end~of~another~creature's~turn.~\RpgStatName{}~regains~spent~legendary~actions~at~the~start~of~its~turn.
			}
			\begin{__rpg_legendary}
				#2
		}{
			\end{__rpg_legendary}
		}

	\NewDocumentCommand {\RpgStatLegendaryAction} {O{} m m }
	{
		\item [ #2 \str_if_empty:NF#1{~(\textbf{#1~actions})}. ] #3
	}



