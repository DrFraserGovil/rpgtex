\ExplSyntaxOn

%%%%%%%%%%%%%%%%%%%%%%%
%%  Define variables %%
%%%%%%%%%%%%%%%%%%%%%%%
	\msg_new:nnn{rpg}{bad-ability}{Cannot~parse~#1~as~a~valid~ability~score}	

	%% assign the skills to the relevant mod macros
	\prop_const_from_keyval:Nn\g__skill_mods
	{
			{athletics}={\l__str_mod},
			{acrobatics}={\l__dex_mod},
			{sleight~of~hand}={\l__dex_mod},
			{stealth}={\l__dex_mod},
			{arcana}={\l__int_mod},
			{history}={\l__int_mod},
			{investigation}={\l__int_mod},
			{nature}={\l__int_mod},
			{religion}={\l__int_mod},
			{animal~handling}={\l__wis_mod},
			{insight}={\l__wis_mod},
			{medicine}={\l__wis_mod},
			{perception}={\l__wis_mod},
			{survival}={\l__wis_mod},
			{deception}={\l__cha_mod},
			{intimidation}={\l__cha_mod},
			{performance}={\l__cha_mod},
			{persuasion}={\l__cha_mod},
	}

	%%to avoid having to write everything 6 times for each stat:
	\seq_const_from_clist:Nn \g__dnd_stats {str,dex,con,int,wis,cha}

	\prop_const_from_keyval:Nn\g__dnd_stats_names
	{
		str={Strength},
		dex={Dexterity},
		con={Constitution},
		int={Intelligence},
		wis={Wisdom},
		cha={Charisma},
	}

	\seq_map_inline:Nn{\g__dnd_stats}{
		\int_new:c{l__#1_mod} %%defines \l__[stat]_mod for each stat in the list
		\tl_new:c{l__#1_save} %%defines \l__[stat]_save for each stat in the list
	} 
	\bool_new:N \l__search_perception
	\seq_new:N \l__seq_holder

%% main preprocessor; called at start of environment
\cs_new_protected_nopar:Npn \__rpg_stat_preprocessing:n#1
{
	\__rpg_check_cr_and_proficiency:
	\seq_map_inline:Nn{\g__dnd_stats}
	{
		\__rpg_store_ability_score_modifier:n{##1}
		\__rpg_store_save_modifier:n{##1}
	}
	\__rpg_stat_process_skills:
	\__rpg_check_initiative:
	\__rpg_check_passive_perception:
	\__rpg_check_nickname:n{#1}
	\__rpg_remap_functions:

	%%colours
	\colorlet{rulecolor}{\l__stat_color}
	\colorlet{statblockcolor}{\l__stat_color!50!black}
	\RpgSetThemeColor{\l__stat_color!25!white}
}


%%%%%%%%%%%%%%%%%%%%%%%%
% Strings & Aliases
%%%%%%%%%%%%%%%%%%%%%%%%

\cs_new_protected_nopar:Npn\__rpg_check_nickname:n#1
{
	\tl_if_empty:eT{\l__rpg_stat_name}
	{
		\tl_set:Ne\l__rpg_stat_name{#1}
	}
}

\cs_new_protected_nopar:Npn\__rpg_remap_functions:
{
	\ProvideDocumentCommand{\action}{m}
	{
		\RpgStatAction{##1}
	}
	\ProvideDocumentCommand{\subaction}{m}
	{
		\RpgStatSubAction{##1}
	}
	\ProvideDocumentCommand{\name}{}
	{
		\l__rpg_stat_name	
	}
	\RenewDocumentCommand{\section}{m}
	{
		\RpgStatSection{##1}
	}
}

%%%%%%%%%%%%%%%%%%%%%%%%
% Modifiers
%%%%%%%%%%%%%%%%%%%%%%%%

	% given (str/dex/etc), retrieves the assigned score, and then saves
	% the modifier (floor(x-10)/2) to the associated modifier variable
	\cs_new_protected_nopar:Npn \__rpg_store_ability_score_modifier:n#1
	{
		%have to do a bit roundabout way to get the expansion to work
		\tl_set_eq:Nc\l_tmpa_tl{l__#1_tl}
		\int_set:Nn\l_tmpa_int{\l_tmpa_tl}
		%now check if the string and the int are the same -- if not, then the argument wasn't an integer!
		\str_compare:eNeF{\int_use:N\l_tmpa_int}{=}{\l_tmpa_tl}
		{
			\msg_error:nne{rpg}{bad-ability}{'\l_tmpa_tl'}
		}
		\int_set:cn{l__#1_mod}{ \fp_eval:n {  floor( (\l_tmpa_int - 10)  / 2) } }

	}

	%% Checks the save bool, and either constructs the modifier into a formatted tl
	%% or (if bool=false), empties the token list. This means only proficient saves
	%% appear in the table
	\cs_new_protected_nopar:Npn \__rpg_store_save_modifier:n#1
	{
		\bool_if:cT{l__#1_save_proficient_bool}
		{
			\tl_set:ce{l__#1_save}{\__rpg_format_signed_integer:N{\int_eval:n{\int_use:c{l__#1_mod} + \g__rpg_proficiency_bonus_int}}}
		}
		{
			\tl_set:ce{l__#1_save}{}
		}
	}
	
	%% Checks if a manual initiative value was passed
	\cs_new_protected_nopar:Npn \__rpg_check_initiative:
	{
		\tl_if_blank:eT{\l__initiative_bonus_tl}
		{
			\tl_set:Ne\l__initiative_bonus_tl{\__rpg_format_signed_integer:N \l__dex_mod}
		}
	}

	%% Checks if a passive perception was passed
	\cs_new_protected_nopar:Npn \__rpg_check_passive_perception:
	{
		\tl_if_blank:eTF{\l__passive_perception_tl}
		{
			\tl_set:Ne\l__passive_perception_tl{\int_eval:n{10+\l__wis_mod}}
			\bool_set_true:N\l__search_perception
		}
		{
			\bool_set_false:N\l__search_perception
		}
	}

	%% Checks if a manual proficiency bonus /challenge rating was passed
	\cs_new_protected_nopar:Npn \__rpg_check_cr_and_proficiency:
	{
		\tl_if_blank:eTF{\g__rpg_proficiency_bonus_int}
		{
			\tl_if_blank:eTF{\l__challenge_tl}
			{
				%% no values provided; assume cr 0
				\tl_set:Nn{\g__rpg_proficiency_bonus_int}{2}
				\tl_set:Nn{\l__challenge_tl}{0}
			}
			{
				%% no PB provided, compute from cr
				\tl_set:Nn{\g__rpg_proficiency_bonus_int}{\fp_eval:n{2+max(0,floor((\l__challenge_tl-1)/4))}}
			}
		}
		{
			\tl_if_blank:eT{\l__challenge_tl}
			{
				%% no CR provided, compute from PB
				\tl_set:Nn{\l__challenge_tl}{\int_eval:n{4*\g__rpg_proficiency_bonus_int-7}}
			}

			%%the fourth option is both CR and PB provided; in which case we do nothing -- just use the user's values
		}
	}

	%%Executes the code in the True block if any of the save bools are true
	\cs_new_protected_nopar:Npn \__rpg_if_any_saves:T#1
	{
		\bool_set_false:N\l_tmpa_bool
		
		\seq_map_inline:Nn{\g__dnd_stats}
		{
			\bool_if:cT{l__##1_save_proficient_bool}
			{
				\bool_set_true:N\l_tmpa_bool
			}
		}
		\bool_if:nT{\l_tmpa_bool}
		{
			#1
		}
	}

	
%%%%%%%%%%%%%%%%%%%%%%%
% Compute Skills
%%%%%%%%%%%%%%%%%%%%%%%
	
	%% check if each skill is in the list, and if so, compute the modifier
	\cs_new_protected:Npn \__rpg_stat_compute_skill_bonus:nn#1#2
	{
		\tl_set:Nn \l_tmpa_tl {\prop_item:Ne\g__skill_mods{\str_lowercase:f{#1}}}
		
		\tl_if_empty:eTF\l_tmpa_tl
		{
			%if not in the list, either a `non D&D skill', or a manual override
			% in either case, just insert the text
			#1
		}
		{
			%otherwise, compute mod + n * prof; and make sure it has a +/- sign
			\tl_set:Ne\l_tmpa_tl{\__rpg_format_signed_integer:N{\fp_eval:n{\l_tmpa_tl + +#2*\g__rpg_proficiency_bonus_int}}}
			#1~(\l_tmpa_tl)
		}
		
		\bool_if:NT{\l__search_perception}
		{
			\str_compare:eNeT{\str_lowercase:f{#1}}{=}{perception}
			{
				\tl_set:Ne{\l__passive_perception_tl}{\fp_eval:n{\l__passive_perception_tl +#2*\g__rpg_proficiency_bonus_int}}
			}
		}
	}

	%% Iterates through the skills comma-list, and tries to compute the modifier
	%% If a 'bad skill' is passed (or a manual override), it just inserts the plain text
	\cs_new_protected:Npn \__rpg_stat_process_skills:
	{
		\seq_clear:N \l__seq_holder

		%%do expertise first (2x prof)
		\clist_map_inline:Nn\l__raw_skills_expertise_tl
		{
			\seq_put_right:Nn\l__seq_holder{\text_titlecase_all:n{\__rpg_stat_compute_skill_bonus:nn{##1}{2}}}
		}

		%%then normal skills (1x prof)
		\clist_map_inline:Nn\l__raw_skills_tl
		{
			\seq_put_right:Nn\l__seq_holder{\text_titlecase_all:n{\__rpg_stat_compute_skill_bonus:nn{##1}{1}}}
		}

		%%save the sequence as a string; use seq to automatically format the list delimiters
		\tl_set:Nn{\l__processed_skills}{\seq_use:Nn{\l__seq_holder}{,~}}
	}

%%%%%%%%%%%%%%%%%%%%
% Misc. helpers
%%%%%%%%%%%%%%%%%%%%

% A toggle-item for descriptions; if the body is empty, the item is not added 
\cs_new_protected_nopar:Npn \__maybe_item:nn #1#2
{
	\tl_if_empty:eF {#2}{ \item [#1] #2 }
}
% Function to format signed integers for display
\cs_new_protected_nopar:Npn \__rpg_format_signed_integer:N #1
{
	\int_compare:nNnTF {#1} < {0}
	{ - }
	{+}
	\int_abs:n {#1}
}

\cs_new_protected_nopar:Npn \__rpg_construct_perception:
{
	\tl_if_blank:eF{\l__senses_tl}
	{
		\l__senses_tl,~
	}
	passive~Perception~ \l__passive_perception_tl
}
